import * as typescript from 'typescript';
import { VirtualCode, CodeMapping, CodeInformation } from '@volar/language-core';
export { CodeInformation, VirtualCode } from '@volar/language-core';
import { Segment } from 'muggle-string';
export { Segment, StackNode, create, getLength, getStack, offsetStack, replace, replaceAll, replaceSourceRange, resetOffsetStack, setTracking, toString, track } from 'muggle-string';
import { FilterPattern } from 'unplugin-utils';

declare const allCodeFeatures: {
    completion: boolean;
    format: boolean;
    navigation: boolean;
    semantic: boolean;
    structure: boolean;
    verification: boolean;
};
declare class TsmVirtualCode implements VirtualCode {
    readonly filePath: string;
    readonly ast: typescript.SourceFile;
    readonly languageId: string;
    private readonly plugins;
    id: string;
    mappings: CodeMapping[];
    embeddedCodes: VirtualCode[];
    codes: Code[];
    snapshot: typescript.IScriptSnapshot;
    source: 'script' | 'scriptSetup' | undefined;
    constructor(filePath: string, ast: typescript.SourceFile, languageId?: string, plugins?: TsmLanguagePlugin[]);
}

type Options = {
    exclude?: FilterPattern;
    include?: FilterPattern;
    plugins?: Plugin[];
};
type Plugin = FactoryReturn | TsmLanguagePlugin | TsmLanguagePlugin[];
type TsmLanguagePlugin = {
    name: string;
    enforce?: 'pre' | 'post';
    resolveVirtualCode?: (virtualCode: TsmVirtualCode) => void;
};
type Context = {
    ts: typeof typescript;
    compilerOptions: typescript.CompilerOptions;
    vueCompilerOptions?: any;
};
type Factory<UserOptions, Nested extends boolean = boolean> = (context: Context, userOptions: UserOptions) => Nested extends true ? Array<TsmLanguagePlugin> : TsmLanguagePlugin;
type FactoryReturn<Nested extends boolean = boolean> = (context: Context) => Nested extends true ? Array<TsmLanguagePlugin> : TsmLanguagePlugin;
type PluginReturn<UserOptions, Nested extends boolean = boolean> = (...args: undefined extends UserOptions ? [UserOptions] | [] : [UserOptions]) => FactoryReturn<Nested>;
type Code = Segment<CodeInformation>;

declare function defineConfig(config: Options): Options;
declare function createPlugin<UserOptions, Nested extends boolean = boolean>(factory: Factory<UserOptions, Nested>): PluginReturn<UserOptions, Nested>;

declare function replaceRange<T extends Segment<any>>(segments: T[], startOffset: number, endOffset: number, ...newSegments: T[]): boolean;

export { type Code, type Context, type Factory, type FactoryReturn, type Options, type Plugin, type PluginReturn, type TsmLanguagePlugin, TsmVirtualCode, allCodeFeatures, createPlugin, defineConfig, replaceRange };
